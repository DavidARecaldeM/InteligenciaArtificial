<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Inteligencia Artificial primera clase 15 de agosto de 2024</h1>
    <p>En la primera clase aprendi a crear un repositorio de github y subir mis proyetos.</p>
    
    <div class="contenedor">
        <h2>Temas Sugeridos</h2>
        <img src="Imagenes/temas-sugeridos.jpg" alt=" " width="700px">
        <p>vimos que datos se repetían y buscamos graficar de cierto que nos brindara dicha información en una grafica de pastel</p>
    </div>

    <div class="contenedor">
        <h2>Actividades similares</h2>
        <img src="Imagenes/actividades similares.jpg" alt="" width="800px">
        <p>Se agruparon las actividades que eran similares y se contaron manualmente</p>
    </div>

    <div class="contenedor">
        <h2>Palabras que se repiten</h2>
        <img src="Imagenes/columna s.jpg" alt="" width="800px">
        <p>Elegimos la columna número 5 y sacamos las palabras repetidas con la ayuda de chatGPT y las rectificamos manualmente <br> e hicimos lo mismo con las palabras únicas (que no se repetían)
            Luego último hicimos la suma de las palabras repetidas y también sacamos <br> el número de palabras únicas y por último hicimos un gráfico circular 3D con los números de las palabras repetidas</p>
    </div>
    <dv class="contenedor">
        <h2>Cantidad de veces que se repiten las inteligencias artificiales</h2>
        <img src="Imagenes/numero de repeticiones.jpeg" alt="" width="800px">
        <p>de manera manual tome los nombres de ias distintas y luego conté cuantas veces se repetía cada una, para al final juntar los valores y generar un anillo con Excel donde podemos ver que lo que vas se repite es chatgpt</p>
    </div>
    <div class="contenedor">
        <h2>Nombre de aplicaciones de inteligencia artificial</h2>
        <img src="Imagenes/nombre de aplicaciones.jpeg" alt="" width="800px">
        <p>yo utilice excel con formulas para sacar las palabras que estaban repetidas separando el texto y luego contando las palabras mas importantes de las inteligencias artificiales utilizando esta formula para contar las palabras que se repiten</p>
    </div>
    <div class="contenedor">
        <h2>Tabla dinamica con nombres de inteligencias artificiales</h2>
        <img src="Imagenes/nombre de ias.jpeg" alt="" width="800px">
        <p>SE REALIZO UTILIZANDO FORMULA DE EXCEL Y TABLAS DINAMICAS.<br> el número de palabras únicas y por último hicimos un gráfico circular 3D con los números de las palabras repetidas</p>
    </div>
    <div class="contenedor">
        <h2>Habilidades blandas</h2>
        <img src="Imagenes/Habilidades blandas.jpeg" alt="" width="800px">
        <p>Nos dimos cuenta que hay varias coincidencias y todas apuntan hacia el hecho de que todos contamos con habilidades blandas suficientes y exactas para llevar a cabo un excelente trabajo en equipo.</p>
    </div>
    <div class="contenedor">
        <h2>Nombres de inteligencias artificiales</h2>
        <img src="Imagenes/numero de repeticiones1.jpeg" alt="" width="800px">
        <p>basicamente lo que hicimos fue indentificar, contar las palabras y finalmente estructuramos los resultados en una tabla  de conteo que permite ver rápidamente <br>
             la frecuencia de cada palabra y proporciona una vision general de los temas mas mencionados. los cuales son la inseguridad, contaminación y transporte</p>
    </div>

    <h2>Segunda clase de inteligencia artificial 22/08/2024</h2>
    <p>En la clase de hoy aprendimos conceptos sobre algoritmos como busqueda tanto en profundidad como en amplitud, tambien sobre la prueba de alan turing</p>

    <H2>Tercera clase de inteligencia artificial 29/08/2024</H2>
    <img src="Imagenes/Neural-Network.webp" alt="">

    <p>En esta clase conocimos acerca de las redes neuronales,como funciona esta y como se crea,ademas de los conceptos basicos
        en los que se basa esta, por ejemplo en este caso se analiza una matriz de 28*28 pixeles, los cuales da como resultados 784
        nodos de inicio,tambien tenemos capas intermedias y capas finales, todo esto sirve para entrenar al algoritmo para que cuando vea un patron similar ya
        se crea una idea de el numero que va a ser, al final esto puede ser tan grande como uno quiera,pero entre mas grande sea mas se va a demorar,sin embargo
        puede obtener resultados mas precisos
    </p>

    <h3>4ta clase de inteligencia artificial 12/09/2024</h3>
    <img src="Imagenes/download.png" alt="">
    <p>En la clase se hoy aprendi a hacer una primera red neuronal haciendo un pequeño ejercicio utilizando tensorFlow, la cual es una libreria para el aprendizaje automatico y numpy la cual sirve para la creacion de vectores y matrices,
         tambien las diferencias en tiempos que se demora en entrenarla cuando solo hay una entrada y cuando hay muchas mas, me doy cuenta que cuando hay mas entradas 
        este proceso toma mas tiempo pero a su vez puede ser mas exacto
    </p>
    <h3>Tabla comparativa de los diferentes algoritmos para resolver laberintos</h3>
    <table border="1">
        <tr>
          <th>Algoritmo</th>
          <th>StackFrontier</th>
          <th>QueueFrontier</th>
        </tr>
        <tr>
          <td>Labertinto 1</td>
          <td>227</td>
          <td>331</td>
        </tr>
        <tr>
          <td>Labertinto 2</td>
          <td>265</td>
          <td>319</td>
        </tr>
      </table>

    <h2>Explicacion de cada linea del codigo del punto numero 4</h2>
      <p><code>import tensorflow as tf</code>: Se importa la biblioteca TensorFlow para la creación y el entrenamiento del modelo de machine learning.</p>
    <p><code>import numpy as np</code>: Se importa NumPy, una biblioteca para manejar arreglos numéricos de manera eficiente.</p>
    <p><code>celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float)</code>: Se crea un arreglo de valores en grados Celsius.</p>
    <p><code>fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float)</code>: Se crea un arreglo de valores correspondientes en grados Fahrenheit.</p>

    <p><code>oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1])</code>: Se crea una capa oculta con 3 neuronas, que recibe como entrada un único valor (grados Celsius).</p>
    <p><code>oculta2 = tf.keras.layers.Dense(units=3)</code>: Se define una segunda capa oculta con 3 neuronas, conectada a la primera capa oculta.</p>
    <p><code>salida = tf.keras.layers.Dense(units=1)</code>: Se define la capa de salida con una sola neurona, que devolverá el valor en grados Fahrenheit.</p>
    <p><code>modelo = tf.keras.Sequential([oculta1, oculta2, salida])</code>: Se define el modelo de forma secuencial, conectando las capas ocultas y la capa de salida.</p>
    <p><code>modelo.compile(optimizer=tf.keras.optimizers.Adam(0.1), loss='mean_squared_error')</code>: Se compila el modelo, definiendo el optimizador como Adam con una tasa de aprendizaje de 0.1 y la función de pérdida como error cuadrático medio.</p>    <p><code>historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False)</code>: El modelo se entrena con los datos de entrada y salida (grados Celsius y Fahrenheit) durante 1000 épocas. El argumento <code>verbose=False</code> desactiva la salida de información durante el entrenamiento.</p>
    <p><code>print("Modelo entrenado!")</code>: Imprime un mensaje indicando que el modelo ha sido entrenado.</p>
    <p><code>import matplotlib.pyplot as plt</code>: Se importa Matplotlib, una biblioteca utilizada para generar gráficos.</p>
    <p><code>plt.xlabel("# Epoca")</code>: Define la etiqueta del eje X como "Época".</p>
    <p><code>plt.ylabel("Magnitud de pérdida")</code>: Define la etiqueta del eje Y como "Magnitud de pérdida".</p>
    <p><code>plt.plot(historial.history["loss"])</code>: Grafica la evolución de la función de pérdida durante el entrenamiento.</p>
    <p><code>print("Hagamos una predicción!")</code>: Imprime un mensaje indicando que se va a realizar una predicción.</p>
    <p><code>resultado = modelo.predict([100.0])</code>: Utiliza el modelo entrenado para predecir el valor en Fahrenheit correspondiente a 100 grados Celsius.</p>
    <p><code>print("El resultado es " + str(resultado) + " fahrenheit!")</code>: Imprime el resultado de la predicción, mostrando el valor predicho en grados Fahrenheit.</p>
    <p><code>print("Variables internas del modelo")</code>: Imprime un mensaje indicando que se van a mostrar los pesos internos del modelo.</p>
    <p><code>print(oculta1.get_weights())</code>: Muestra los pesos aprendidos por la primera capa oculta.</p>
    <p><code>print(oculta2.get_weights())</code>: Muestra los pesos aprendidos por la segunda capa oculta.</p>
    <p><code>print(salida.get_weights())</code>: Muestra los pesos aprendidos por la capa de salida.</p>


    <h3>Resultados encuestas</h3>
    <h2>En esta encuesta se realizo era para ver carreras que podrian ser una buena opcion para el encuestado</h2>
    <h4>Intereses:</h4>

    <img src="Imagenes/foto1Intereses.PNG" alt="">
    <h4>Zona de trabajo</h4>
    <img src="Imagenes/foto2zonatrabajo4.PNG" alt="">
    <h4>Profesiones:</h4>
    <img src="Imagenes/fotoprofesiones.PNG" alt="">
    <img src="Imagenes/fotoprofesiones2.PNG" alt="">

    <h4>Resultado Encuesta 2</h4>
    <h3>Elección fuerte</h3>
    <p>En esta encuesta se respondieron una serie de preguntas que permitian ver cual era la especialidad o punto fuerte en el ambito de la informatica para la persona.</p>
    <img src="Imagenes/resultados backend.PNG" alt="" width="40%">
    <p>Los resultados completos obtenidos se pueden ver en el siguiente enlace: https://drive.google.com/file/d/1aeMP8OWF0n2q20Q9CWNbAys7H1owOt0z/view?usp=drive_link</p>
      

    <h4>Segundo parcial punto 5</h4>
    <h5>Codigo comentado</h5>
        <code>
# Importar la biblioteca itertools para trabajar con iteradores
import itertools

# Definir la clase base para todas las sentencias lógicas
class Sentence():
    # Método para evaluar la sentencia
    def evaluate(self, model):
        """Evaluates the logical sentence."""
        raise Exception("nothing to evaluate")

    # Método para obtener la fórmula como cadena
    def formula(self):
        """Returns string formula representing logical sentence."""
        return ""

    # Método para obtener los símbolos utilizados en la sentencia
    def symbols(self):
        """Returns a set of all symbols in the logical sentence."""
        return set()

    # Método de clase para validar si una sentencia es una instancia de Sentence
    @classmethod
    def validate(cls, sentence):
        if not isinstance(sentence, Sentence):
            raise TypeError("must be a logical sentence")

    # Método de clase para agregar paréntesis a una expresión si no los tiene
    @classmethod
    def parenthesize(cls, s):
        """Parenthesizes an expression if not already parenthesized."""
        def balanced(s):
            """Checks if a string has balanced parentheses."""
            count = 0
            for c in s:
                if c == "(":
                    count += 1
                elif c == ")":
                    if count <= 0:
                        return False
                    count -= 1
            return count == 0
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):
            return s
        else:
            return f"({s})"


# Definir la clase para representar un símbolo lógico (una variable booleana)
class Symbol(Sentence):
    # Constructor para inicializar el símbolo con un nombre
    def __init__(self, name):
        self.name = name

    # Método para evaluar el símbolo en un modelo
    def evaluate(self, model):
        try:
            return bool(model[self.name])
        except KeyError:
            raise EvaluationException(f"variable {self.name} not in model")

    # Método para obtener la fórmula como cadena
    def formula(self):
        return self.name

    # Método para obtener los símbolos utilizados en la sentencia
    def symbols(self):
        return {self.name}

    # Método para comparar dos símbolos
    def __eq__(self, other):
        return isinstance(other, Symbol) and self.name == other.name

    # Método para obtener el hash de un símbolo
    def __hash__(self):
        return hash(("symbol", self.name))

    # Método para representar un símbolo como cadena
    def __repr__(self):
        return self.name


# Definir la clase para representar la negación de una sentencia lógica
class Not(Sentence):
    # Constructor para inicializar la negación con una sentencia
    def __init__(self, operand):
        Sentence.validate(operand)
        self.operand = operand

    # Método para evaluar la negación en un modelo
    def evaluate(self, model):
        return not self.operand.evaluate(model)

    # Método para obtener la fórmula como cadena
    def formula(self):
        return "¬" + Sentence.parenthesize(self.operand.formula())

    # Método para obtener los símbolos utilizados en la sentencia
    def symbols(self):
        return self.operand.symbols()

    # Método para comparar dos negaciones
    def __eq__(self, other):
        return isinstance(other, Not) and self.operand == other.operand

    # Método para obtener el hash de una negación
    def __hash__(self):
        return hash(("not", hash(self.operand)))

    # Método para representar una negación como cadena
    def __repr__(self):
        return f"Not({self.operand})"


# Definir la clase para representar la conjunción de varias sentencias lógicas
class And(Sentence):
    # Constructor para inicializar la conjunción con varias sentencias
    def __init__(self, *conjuncts):
        for conjunct in conjuncts:
            Sentence.validate(conjunct)
        self.conjuncts = list(conjuncts)

    # Método para evaluar la conjunción en un modelo
    def evaluate(self, model):
        return all(conjunct.evaluate(model) for conjunct in self.conjuncts)

    # Método para obtener la fórmula como cadena
    def formula(self):
        if len(self.conjuncts) == 1:
            return self.conjuncts[0].formula()
        return

    </code>

    <p>el codigo anterior proporciona una implementación de un sistema de lógica proposicional que permite crear y evaluar sentencias lógicas, así como verificar si un conjunto de conocimientos implica una sentencia.</p>


<h4>Explicacion del codigo del punto numero 6</h4>
<code>
    # Importar todas las clases y funciones del módulo 'logic'
from logic import *

# Definir símbolos lógicos que representarán proposiciones
lluvia = Symbol("lluvia")        # Representa la proposición "lluvia"
BBC = Symbol("BBC")              # Representa la proposición "BBC"
Unimayor = Symbol("Unimayor")    # Representa la proposición "Unimayor"

# Definir el conocimiento lógico en forma de conjunción
knowledge = And(
    Implication(Not(lluvia), BBC),  # Si no hay lluvia, entonces hay BBC
    Or(BBC, Unimayor),               # Hay BBC o hay Unimayor (o ambos)
    Not(And(BBC, Unimayor)),         # No puede haber BBC y Unimayor al mismo tiempo
    Unimayor                         # Debe haber Unimayor
)

# Comprobar si el conocimiento implica que hay lluvia
print(model_check(knowledge, lluvia))
</code>
        
</body>

</body>
</html>
